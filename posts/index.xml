<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on C&#43;&#43; Minor</title>
		<link>https://atyuwen.github.io/posts/</link>
		<description>Recent content in Posts on C&#43;&#43; Minor</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 20 Jan 2020 09:58:17 +0800</lastBuildDate>
		<atom:link href="https://atyuwen.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Accurate Normal Reconstruction from Depth Buffer</title>
			<link>https://atyuwen.github.io/posts/normal-reconstruction/</link>
			<pubDate>Mon, 20 Jan 2020 09:58:17 +0800</pubDate>
			
			<guid>https://atyuwen.github.io/posts/normal-reconstruction/</guid>
			<description>Months ago I read a nice article 1 about normal reconstruction by János Turánszki (@turanszkij), which reminded me that I had also tackled this problem before, but for a different purpose. While Turánszki reconstructed normal from depth buffer for better SSAO, I was aimed for rendering decals.
In screen-space decals rendering, normal buffer is required to reject pixels projected onto near-perpendicular surfaces. But back then I was working on a forward pipeline, so no normal buffer was outputted.</description>
			<content type="html"><![CDATA[<p>Months ago I read a nice article <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> about normal reconstruction by János Turánszki (@turanszkij), which reminded me that I had also tackled this problem before, but for a different purpose. While Turánszki reconstructed normal from depth buffer for better SSAO, I was aimed for rendering decals.</p>
<p>In screen-space decals rendering, normal buffer is required to reject pixels projected onto near-perpendicular surfaces. But back then I was working on a forward pipeline, so no normal buffer was outputted. It seemed the best choice was to reconstruct it directly from depth buffer, as long as we could avoid introducing errors, which was not easy though. Fortunately, accurate normal reconstruction is impossible in theory but possible in practice, we eventually found a way inspired by Humus's SDAA idea <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>, which is more accurate but also more expensive than Turánszki's method. However, it's worth the cost because decals are highly sensitive to the reconstruction errors. Following shows decals rendered in purple with different normal reconstruction strategies.</p>
<figure>
    <img src="/posts/images/normal-reconstruction-decals.png"/> 
</figure>

<ul>
<li>Left: simply uses cross(ddx, ddy), note the artifacts in areas labeled with <strong>a</strong>, <strong>b</strong>, and <strong>c</strong>.</li>
<li>Middle: the <em>improved approach</em> <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>, the artifacts in <strong>a</strong> disappeared, but those in <strong>b</strong> and <strong>c</strong> still exist.</li>
<li>Right: our <em>accurate method</em>, all artifacts are eliminated.</li>
</ul>
<hr>
<p>To understand how those artifacts occur and disappear, I drawn a picture to illustrate the two typical types of discontinuities in depth buffer, in which the eye and arrow denote the camera position and direction respectively, and the blue dots denote the depth samples.</p>
<figure>
    <img src="/posts/images/depth-discontinuities.png" width="600px"/> 
</figure>

<p>In figure (1), Turánszki's method works very well. 3 taps are enough to eliminate errors: since $|d-c|$ is less than $|b-c|$, we can say that point $c$ is more likely on segment $de$ rather than segment $ab$. But this is not the case in figure (2): although $|b-c| &lt; |d-c|$, the point $c$ is apparently on segment $de$ instead of $ab$. This observation perfectly explains why the <em>improved approach</em> can only remove part of the artifacts in decal rendering.</p>
<p>So we can conclude that 3 taps (on each direction) is inadequate. Humus's SDAA <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> uses 5 sample taps along with a second depth layer to calculate edge locations, here we can use the same 5-tap pattern to determinate whether $c$ is on $ab$ or $de$. (Unlike SDAA, we don't have to calculate the accurate edge location, so the second-depth buffer is not needed.) Following describes the method step by step.</p>
<figure>
    <img src="/posts/images/depth-discontinuities-2.png" width="600px"/> 
</figure>

<ul>
<li>Extrapolate segment $ab$ to $c$, get a new point $c_1$.</li>
<li>Extrapolate segment $ed$ to $c$, get a new point $c_2$.</li>
<li>If $|c_1-c| &lt; |c_2-c|$, report $c$ is on $ab$, otherwise report $c$ is on $de$.</li>
</ul>
<p>Note this method can locate $c$ correctly in both figure (1) and (2). Now we can apply this algorithm twice to get horizontal and vertical derivatives, then a cross product gives you the normal accurately. Here is the pseudo shader code.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Try reconstructing normal accurately from depth buffer.
</span><span class="c1"></span><span class="c1">// input DepthBuffer: stores linearized depth in range (0, 1).
</span><span class="c1"></span><span class="c1">// 5 taps on each direction: | z | x | * | y | w |, &#39;*&#39; denotes the center sample.
</span><span class="c1"></span><span class="n">float3</span> <span class="nf">ReconstructNormal</span><span class="p">(</span><span class="n">texture2D</span> <span class="n">DepthBuffer</span><span class="p">,</span> <span class="n">float2</span> <span class="nl">spos</span><span class="p">:</span> <span class="n">SV_Position</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">stc</span> <span class="o">=</span> <span class="n">spos</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

    <span class="n">float4</span> <span class="n">H</span><span class="p">;</span>
    <span class="n">H</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">H</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">+</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">H</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">H</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">+</span> <span class="n">float2</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">he</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">H</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">H</span><span class="p">.</span><span class="n">zw</span> <span class="o">*</span> <span class="n">rcp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">H</span><span class="p">.</span><span class="n">zw</span> <span class="o">-</span> <span class="n">H</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span> <span class="o">-</span> <span class="n">depth</span><span class="p">)</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">hDeriv</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">he</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">he</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">hDeriv</span> <span class="o">=</span> <span class="n">Calculate</span> <span class="n">horizontal</span> <span class="n">derivative</span> <span class="n">of</span> <span class="n">world</span> <span class="n">position</span> <span class="n">from</span> <span class="n">taps</span> <span class="o">|</span> <span class="n">z</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span>
    <span class="k">else</span>
        <span class="n">hDeriv</span> <span class="o">=</span> <span class="n">Calculate</span> <span class="n">horizontal</span> <span class="n">derivative</span> <span class="n">of</span> <span class="n">world</span> <span class="n">position</span> <span class="n">from</span> <span class="n">taps</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">w</span> <span class="o">|</span>

    <span class="n">float4</span> <span class="n">V</span><span class="p">;</span>
    <span class="n">V</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">V</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">+</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">V</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">-</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">V</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">DepthBuffer</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">DepthBuffer_Sampler</span><span class="p">,</span> <span class="n">stc</span> <span class="o">+</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">ve</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">xy</span> <span class="o">*</span> <span class="n">V</span><span class="p">.</span><span class="n">zw</span> <span class="o">*</span> <span class="n">rcp</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">V</span><span class="p">.</span><span class="n">zw</span> <span class="o">-</span> <span class="n">V</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span> <span class="o">-</span> <span class="n">depth</span><span class="p">)</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">vDeriv</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ve</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">ve</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">vDeriv</span> <span class="o">=</span> <span class="n">Calculate</span> <span class="n">vertical</span> <span class="n">derivative</span> <span class="n">of</span> <span class="n">world</span> <span class="n">position</span> <span class="n">from</span> <span class="n">taps</span> <span class="o">|</span> <span class="n">z</span> <span class="o">|</span> <span class="n">x</span> <span class="o">|</span>
    <span class="k">else</span>
        <span class="n">vDeriv</span> <span class="o">=</span> <span class="n">Calculate</span> <span class="n">vertical</span> <span class="n">derivative</span> <span class="n">of</span> <span class="n">world</span> <span class="n">position</span> <span class="n">from</span> <span class="n">taps</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">w</span> <span class="o">|</span>

    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">hDeriv</span><span class="p">,</span> <span class="n">vDeriv</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><em>Feb 16 Update</em>: The <code>he</code> and <code>ve</code> in above code are so calculated because we need to do perspective correct interpolation here, i.e, interpolating on 1/depth instead of depth.</p>
<p>At last I need to say that this <em>accurate method</em> may still fail on tiny triangles, but it's rarely noticeable. We've used this technique in decal rendering for years, our artists never complain about any artifact. Hope you find it useful.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>János Turánszki, &ldquo;Improved normal reconstruction from depth&rdquo;. <a href="https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth">https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth</a>. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Emil Persson. “Second-Depth Antialiasing”. In GPU Pro 4, A K Peters, 2013, pp. 201–212. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
		</item>
		
		<item>
			<title>Draw Anti-aliased Lines with Geometry Shader</title>
			<link>https://atyuwen.github.io/posts/antialiased-line/</link>
			<pubDate>Wed, 01 Jan 2020 09:20:55 +0800</pubDate>
			
			<guid>https://atyuwen.github.io/posts/antialiased-line/</guid>
			<description>For engine programmers, there are many cases you have to draw lines on screen, e.g. rendering a grid on the ground, drawing bounding boxes and other helper objects. Usually it&#39;s not a problem if you are very used to the jaggies, but recently I can&#39;t stand it anymore, my eyes complain to me that they want anti-aliased lines. After a quick search on google, it surprises me that there is no existing handy code piece can meet my needs.</description>
			<content type="html"><![CDATA[<p>For engine programmers, there are many cases you have to draw lines on screen, e.g. rendering a grid on the ground, drawing bounding boxes and other helper objects. Usually it's not a problem if you are very used to the jaggies, but recently I can't stand it anymore, my eyes complain to me that they want anti-aliased lines. After a quick search on google, it surprises me that there is no existing handy code piece can meet my needs. So, it's time to do research!</p>
<hr>
<p>The first thing comes to my eye is an old article &ldquo;Fast Prefiltered Lines&rdquo; <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. It describes a method that can draw pretty high quality anti-aliased lines with fixed cost, since the filter is pre-calculated. It's a great article but I can't use it directly for several reasons:</p>
<ul>
<li>It's mainly about drawing 2D lines, so perspective projection is not considered.</li>
<li>It uses CPU to calculate edge equations, but I want to keep changes to a minimum in my cpp code.</li>
<li>It uses shader uniforms to pass the edge equations to pixel shader, which means you can only draw a single line in one DP.</li>
</ul>
<p>Fortunately now the programmable pipeline is way more flexible than in 2005. With <strong>geometry shader</strong>, we can do it much easier. Following shows the final rendered image, and I'll describe the details in below.</p>
<figure>
    <img src="/posts/images/messiah-line.png" width="500px"/> 
</figure>

<hr>
<p>First, draw lines as usual: there is no change needed for host code and vertex shader. Then, add following geometry shader to expand 1-pixel-width lines to 3-pixel-width quads in screen space, and store <em>distance to line center</em> in <code>TexCoord.x</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">GeometryOutput</span>
<span class="p">{</span>
	<span class="n">float4</span>                <span class="nl">HPosition</span> <span class="p">:</span> <span class="n">SV_Position</span><span class="p">;</span>
<span class="hl">	<span class="n">noperspective</span> <span class="n">float2</span>  <span class="nl">TexCoord</span>  <span class="p">:</span> <span class="n">TEXCOORDN</span><span class="p">;</span>           <span class="c1">// section 2
</span></span><span class="c1"></span><span class="p">}</span><span class="p">;</span>

<span class="p">[</span><span class="n">maxvertexcount</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">]</span>
<span class="kt">void</span> <span class="n">AALineGS</span><span class="p">(</span><span class="n">line</span> <span class="n">VertexOutput</span> <span class="n">IN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">,</span> <span class="n">inout</span> <span class="n">TriangleStream</span><span class="o">&lt;</span><span class="n">GeometryOutput</span><span class="o">&gt;</span> <span class="n">OUT</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VertexOutput</span> <span class="n">P0</span> <span class="o">=</span> <span class="n">IN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>
	<span class="n">VertexOutput</span> <span class="n">P1</span> <span class="o">=</span> <span class="n">IN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">VertexOutput</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">P0</span><span class="p">;</span>
		<span class="n">P0</span> <span class="o">=</span> <span class="n">P1</span><span class="p">;</span>
		<span class="n">P1</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="hl">	<span class="k">if</span> <span class="p">(</span><span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span> <span class="o">&lt;</span> <span class="n">NearPlane</span><span class="p">)</span>                        <span class="c1">// section 1
</span></span><span class="hl"><span class="c1"></span>	<span class="p">{</span>
</span><span class="hl">		<span class="kt">float</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">NearPlane</span> <span class="o">-</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span> <span class="o">-</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">)</span><span class="p">;</span>
</span><span class="hl">		<span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">,</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">,</span> <span class="n">ratio</span><span class="p">)</span><span class="p">;</span>
</span><span class="hl">	<span class="p">}</span>
</span>
	<span class="n">float2</span> <span class="n">a</span> <span class="o">=</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
	<span class="n">float2</span> <span class="n">b</span> <span class="o">=</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">xy</span> <span class="o">/</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
	<span class="n">float2</span> <span class="n">c</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="p">)</span> <span class="o">/</span> <span class="n">ScreenSize</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>

	<span class="n">GeometryOutput</span> <span class="n">g0</span><span class="p">;</span>
	<span class="n">g0</span><span class="p">.</span><span class="n">HPosition</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">zw</span><span class="p">)</span><span class="p">;</span>
	<span class="n">g0</span><span class="p">.</span><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span><span class="p">;</span>
	<span class="n">GeometryOutput</span> <span class="n">g1</span><span class="p">;</span>
	<span class="n">g1</span><span class="p">.</span><span class="n">HPosition</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">P0</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">zw</span><span class="p">)</span><span class="p">;</span>
	<span class="n">g1</span><span class="p">.</span><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span><span class="p">;</span>
	<span class="n">GeometryOutput</span> <span class="n">g2</span><span class="p">;</span>
	<span class="n">g2</span><span class="p">.</span><span class="n">HPosition</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">zw</span><span class="p">)</span><span class="p">;</span>
	<span class="n">g2</span><span class="p">.</span><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span><span class="p">;</span>
	<span class="n">GeometryOutput</span> <span class="n">g3</span><span class="p">;</span>
	<span class="n">g3</span><span class="p">.</span><span class="n">HPosition</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">xy</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">w</span><span class="p">,</span> <span class="n">P1</span><span class="p">.</span><span class="n">HPosition</span><span class="p">.</span><span class="n">zw</span><span class="p">)</span><span class="p">;</span>
	<span class="n">g3</span><span class="p">.</span><span class="n">TexCoord</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span><span class="p">;</span>

	<span class="n">OUT</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">g0</span><span class="p">)</span><span class="p">;</span>
	<span class="n">OUT</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span><span class="p">;</span>
	<span class="n">OUT</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span><span class="p">;</span>
	<span class="n">OUT</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">g3</span><span class="p">)</span><span class="p">;</span>
	<span class="n">OUT</span><span class="p">.</span><span class="n">RestartStrip</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>The above code is pretty straightforward, except two places I would like to explain further:</p>
<ul>
<li>The highlighted <em>section 1</em> does a manual near-plane clipping to ensure all lines passed out are <strong>internal lines</strong>. This is necessary because it's meaningless to calculate screen position for points behind the camera, which will mess things up.</li>
<li>The keyword <strong>noperspective</strong> in <em>section 2</em> is to tell the rasterizer to interpolate <code>TexCoord</code> in screen space rather than in world space, which is exactly what we want, since we are drawing lines with constant width in pixels.</li>
</ul>
<hr>
<p>Finally the pixel shader. Since we already have <code>TexCoord.x</code> represents the distance field, it's not difficult to fade the pixel base on that to get anti-aliased lines. However, in order to get better AA quality, we have to choose the filter very carefully. It turns out $2^{-2.7 \cdot d \cdot d}$ can fit the <strong>cone filter kernel</strong> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> very well.</p>
<figure>
    <img src="/posts/images/line-filter.png" width="500px"/> 
</figure>

<p>Now here is the full PS code, and we are done!</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">float4</span> <span class="nf">AALinePS</span><span class="p">(</span><span class="n">in</span> <span class="n">GeometryOutput</span> <span class="n">IN</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">exp2</span><span class="p">(</span><span class="o">-</span><span class="mf">2.7</span> <span class="o">*</span> <span class="n">IN</span><span class="p">.</span><span class="n">TexCoord</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">IN</span><span class="p">.</span><span class="n">TexCoord</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">LineColor</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Eric Chan and Frédo Durand. “Fast Prefiltered Lines”. In GPU Gems 2, Addison-Wesley, 2005, pp. 345–359. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>McNamara, Robert, Joel McCormack, and Norman P. Jouppi. 2000. &ldquo;Prefiltered Antialiased Lines Using Half-Plane Distance Functions.&rdquo; In Proceedings of the ACM SIGGRAPH/Eurographics Workshop on Graphics Hardware, pp. 77–85. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
		</item>
		
	</channel>
</rss>
